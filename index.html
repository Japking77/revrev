<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio Revenue Analyzer - Freewyld Foundry</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { min-height: 100vh; background: linear-gradient(135deg, #0a0f0d 0%, #1a2f23 50%, #0d1a14 100%); color: #e8f0eb; font-family: 'DM Sans', sans-serif; padding: 40px 20px; }
    .header { text-align: center; margin-bottom: 48px; }
    .logo { display: inline-flex; align-items: center; gap: 12px; margin-bottom: 24px; padding: 12px 24px; background: rgba(46, 90, 61, 0.3); border: 1px solid rgba(46, 90, 61, 0.5); border-radius: 100px; }
    .logo-icon { font-size: 24px; color: #7cb88c; }
    .logo-text { font-family: 'Space Mono', monospace; font-weight: 700; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: #7cb88c; }
    h1 { font-size: 48px; font-weight: 700; margin-bottom: 12px; background: linear-gradient(135deg, #e8f0eb 0%, #7cb88c 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .subtitle { font-size: 18px; color: #8aa894; max-width: 600px; margin: 0 auto; }
    .progress-bar { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 48px; }
    .progress-step { display: flex; align-items: center; gap: 8px; opacity: 0.4; transition: opacity 0.3s; }
    .progress-step.active { opacity: 1; }
    .step-number { width: 32px; height: 32px; border-radius: 50%; background: rgba(46, 90, 61, 0.5); border: 2px solid #2e5a3d; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
    .progress-step.active .step-number { background: #2e5a3d; border-color: #7cb88c; }
    .step-label { font-size: 14px; font-weight: 500; }
    .progress-line { width: 60px; height: 2px; background: rgba(46, 90, 61, 0.5); }
    .error-banner { max-width: 800px; margin: 0 auto 24px; padding: 16px 24px; background: rgba(180, 60, 60, 0.2); border: 1px solid rgba(180, 60, 60, 0.5); border-radius: 12px; display: none; align-items: center; gap: 12px; }
    .error-banner.show { display: flex; }
    .section { max-width: 900px; margin: 0 auto; background: rgba(20, 35, 28, 0.8); border: 1px solid rgba(46, 90, 61, 0.3); border-radius: 24px; padding: 40px; backdrop-filter: blur(10px); display: none; }
    .section.active { display: block; }
    h2 { font-size: 28px; margin-bottom: 32px; color: #e8f0eb; }
    h3 { font-size: 18px; margin-bottom: 16px; color: #8aa894; }
    .help-text { font-size: 14px; color: #6a8a74; margin-bottom: 12px; }
    .upload-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 32px; }
    .upload-box { position: relative; padding: 32px; border: 2px dashed rgba(46, 90, 61, 0.5); border-radius: 16px; text-align: center; cursor: pointer; transition: all 0.3s; background: rgba(46, 90, 61, 0.1); }
    .upload-box:hover { border-color: #7cb88c; background: rgba(46, 90, 61, 0.2); }
    .upload-box.uploaded { border-color: #7cb88c; border-style: solid; background: rgba(46, 90, 61, 0.2); }
    .upload-box input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .upload-icon { font-size: 32px; margin-bottom: 12px; color: #7cb88c; }
    .upload-label { font-weight: 600; margin-bottom: 8px; }
    .required { color: #b88c7c; margin-left: 4px; }
    .file-name { font-size: 12px; color: #7cb88c; font-family: 'Space Mono', monospace; margin-top: 8px; word-break: break-all; }
    .compset-section { margin-bottom: 32px; }
    .compset-upload { padding: 24px; border: 2px dashed rgba(46, 90, 61, 0.5); border-radius: 16px; background: rgba(46, 90, 61, 0.1); }
    .compset-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px; }
    .compset-chip { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: rgba(46, 90, 61, 0.3); border-radius: 100px; font-size: 13px; font-family: 'Space Mono', monospace; }
    .compset-chip button { background: none; border: none; color: #8aa894; cursor: pointer; font-size: 16px; }
    .primary-btn, .secondary-btn { padding: 16px 32px; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; border: none; }
    .primary-btn { background: linear-gradient(135deg, #2e5a3d 0%, #3d7a52 100%); color: #e8f0eb; box-shadow: 0 4px 20px rgba(46, 90, 61, 0.4); }
    .primary-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(46, 90, 61, 0.6); }
    .primary-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .secondary-btn { background: transparent; color: #8aa894; border: 2px solid rgba(46, 90, 61, 0.5); }
    .secondary-btn:hover { border-color: #7cb88c; color: #e8f0eb; }
    .btn-group { display: flex; gap: 16px; justify-content: center; margin-top: 32px; }
    .config-form { margin-bottom: 32px; }
    .config-form label { display: block; margin-bottom: 24px; font-weight: 500; }
    .config-form input[type="text"] { width: 100%; margin-top: 8px; padding: 16px; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(46, 90, 61, 0.5); border-radius: 12px; color: #e8f0eb; font-size: 16px; }
    .config-form input[type="text"]:focus { outline: none; border-color: #7cb88c; }
    .file-summary { padding: 24px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; }
    .file-summary ul { list-style: none; }
    .file-summary li { padding: 8px 0; font-family: 'Space Mono', monospace; font-size: 13px; color: #7cb88c; }
    .results-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 32px; }
    .result-card { padding: 24px; background: rgba(0, 0, 0, 0.3); border-radius: 16px; border: 1px solid rgba(46, 90, 61, 0.3); }
    .result-card.highlight { background: rgba(46, 90, 61, 0.2); border-color: rgba(46, 90, 61, 0.5); }
    .result-card.accent { background: rgba(124, 184, 140, 0.1); border-color: rgba(124, 184, 140, 0.3); }
    .result-card.success { background: linear-gradient(135deg, rgba(46, 90, 61, 0.3) 0%, rgba(124, 184, 140, 0.2) 100%); border-color: #7cb88c; }
    .card-label { font-size: 13px; color: #8aa894; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .card-value { font-size: 28px; font-weight: 700; font-family: 'Space Mono', monospace; }
    .result-card.success .card-value { color: #7cb88c; }
    .scores-section { margin-bottom: 24px; }
    .scores-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
    .score-item { padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; text-align: center; }
    .score-label { font-size: 12px; color: #8aa894; margin-bottom: 8px; }
    .score-value { font-size: 24px; font-weight: 700; font-family: 'Space Mono', monospace; color: #7cb88c; }
    .unit-summary { padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; text-align: center; margin-bottom: 24px; }
    .unit-summary p { color: #8aa894; margin-top: 8px; }
    .export-info { padding: 24px; background: rgba(46, 90, 61, 0.15); border: 1px solid rgba(46, 90, 61, 0.3); border-radius: 12px; margin-bottom: 24px; }
    .export-info ul { list-style: none; }
    .export-info li { padding: 8px 0; color: #8aa894; }
    .export-info strong { color: #e8f0eb; }
    .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-right: 10px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @media (max-width: 768px) { .upload-grid { grid-template-columns: 1fr; } .results-grid { grid-template-columns: 1fr; } .scores-grid { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 32px; } }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo"><span class="logo-icon">‚óÜ</span><span class="logo-text">Freewyld Foundry</span></div>
    <h1>Portfolio Revenue Analyzer</h1>
    <p class="subtitle">Upload your data to generate comprehensive T-12 revenue analysis with formatted Excel export</p>
  </div>

  <div class="progress-bar">
    <div class="progress-step active" id="step1-indicator"><div class="step-number">1</div><div class="step-label">Upload Files</div></div>
    <div class="progress-line"></div>
    <div class="progress-step" id="step2-indicator"><div class="step-number">2</div><div class="step-label">Configure</div></div>
    <div class="progress-line"></div>
    <div class="progress-step" id="step3-indicator"><div class="step-number">3</div><div class="step-label">Results</div></div>
  </div>

  <div class="error-banner" id="error-banner">
    <span class="error-icon">‚ö†</span>
    <span id="error-message"></span>
    <button onclick="hideError()">√ó</button>
  </div>

  <div class="section active" id="step1">
    <h2>Upload Portfolio Data</h2>
    <div class="upload-grid">
      <div class="upload-box" id="listings-box">
        <div class="upload-icon" id="listings-icon">‚Üë</div>
        <div class="upload-label">Portfolio Listings<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('listings', this)">
        <div class="file-name" id="listings-name"></div>
      </div>
      <div class="upload-box" id="revenue-box">
        <div class="upload-icon" id="revenue-icon">‚Üë</div>
        <div class="upload-label">Historic Revenue<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('revenue', this)">
        <div class="file-name" id="revenue-name"></div>
      </div>
      <div class="upload-box" id="bookings-box">
        <div class="upload-icon" id="bookings-icon">‚Üë</div>
        <div class="upload-label">Bookings Report<span class="required">*</span></div>
        <input type="file" accept=".xlsx,.xls,.csv" onchange="handleFile('bookings', this)">
        <div class="file-name" id="bookings-name"></div>
      </div>
      <div class="upload-box" id="market-box">
        <div class="upload-icon" id="market-icon">‚Üë</div>
        <div class="upload-label">Market Occupancy<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('market', this)">
        <div class="file-name" id="market-name"></div>
      </div>
    </div>
    <div class="compset-section">
      <h3>Compset Files (by bedroom)</h3>
      <p class="help-text">Upload one CSV file per bedroom type with Revenue and Bedrooms columns.</p>
      <div class="compset-upload">
        <input type="file" accept=".csv" multiple onchange="handleCompsets(this)">
        <div class="compset-list" id="compset-list"></div>
      </div>
    </div>
    <button class="primary-btn" id="continue-btn" onclick="goToStep(2)" disabled>Continue ‚Üí</button>
  </div>

  <div class="section" id="step2">
    <h2>Configure Analysis</h2>
    <div class="config-form">
      <label>Portfolio Name<input type="text" id="portfolio-name" value="Portfolio" placeholder="e.g., West Palm Beach"></label>
      <div class="file-summary">
        <h3>Files Loaded</h3>
        <ul id="files-summary"></ul>
      </div>
    </div>
    <div class="btn-group">
      <button class="secondary-btn" onclick="goToStep(1)">‚Üê Back</button>
      <button class="primary-btn" id="analyze-btn" onclick="runAnalysis()">Run Analysis ‚Üí</button>
    </div>
  </div>

  <div class="section" id="step3">
    <h2>Analysis Results</h2>
    <div class="results-grid" id="results-grid"></div>
    <div class="scores-section">
      <h3>Pacing Scores</h3>
      <div class="scores-grid" id="scores-grid"></div>
    </div>
    <div class="unit-summary"><h3>Unit Summary</h3><p id="unit-summary-text"></p></div>
    <div class="export-info">
      <h3>Excel Export Includes</h3>
      <ul>
        <li>üìä <strong>Dashboard</strong> - Revenue summary, RPM projections, pacing scores</li>
        <li>üìà <strong>T-12 Revenue</strong> - All listings with actual/projected revenue and percentiles</li>
        <li>üìÖ <strong>Occupancy Pacing</strong> - Monthly MPI vs MPIT analysis</li>
        <li>üè† <strong>Listing Pacing</strong> - Individual unit forward occupancy</li>
      </ul>
    </div>
    <div class="btn-group">
      <button class="secondary-btn" onclick="goToStep(1)">‚Üê Start Over</button>
      <button class="primary-btn" onclick="generateExcel()">‚Üì Download Excel Report</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
  <script>
    const files = { listings: null, revenue: null, bookings: null, market: null, compsets: [] };
    let analysis = null;

    const FEE_TIERS = [
      { min: 0, max: 2000000, rate: 0.03 }, { min: 2000000, max: 3000000, rate: 0.025 },
      { min: 3000000, max: 4000000, rate: 0.02 }, { min: 4000000, max: 5000000, rate: 0.0175 },
      { min: 5000000, max: 7000000, rate: 0.016 }, { min: 7000000, max: 9000000, rate: 0.014 },
      { min: 9000000, max: 12000000, rate: 0.0125 }, { min: 12000000, max: 15000000, rate: 0.011 },
      { min: 15000000, max: Infinity, rate: 0.01 },
    ];

    const getFeeRate = (revenue) => FEE_TIERS.find(t => revenue >= t.min && revenue < t.max) || FEE_TIERS[0];
    const roundTo100k = (v) => Math.round(v / 100000) * 100000;
    const roundTo5k = (v) => Math.round(v / 5000) * 5000;
    const roundTo1k = (v) => Math.round(v / 1000) * 1000;
    const formatCurrency = (val) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(val);
    const percentileOfScore = (arr, value) => { const sorted = [...arr].sort((a, b) => a - b); return (sorted.filter(v => v <= value).length / sorted.length) * 100; };
    const valueAtPercentile = (arr, pct) => { const sorted = [...arr].sort((a, b) => a - b); return sorted[Math.min(Math.floor((pct / 100) * sorted.length), sorted.length - 1)]; };

    function getVal(obj, ...keys) {
      for (const key of keys) {
        if (obj[key] !== undefined && obj[key] !== null && obj[key] !== '') return obj[key];
      }
      return null;
    }

    function showError(msg) { document.getElementById('error-message').textContent = msg; document.getElementById('error-banner').classList.add('show'); }
    function hideError() { document.getElementById('error-banner').classList.remove('show'); }

    function updateContinueButton() {
      document.getElementById('continue-btn').disabled = !(files.listings && files.revenue && files.market && files.bookings);
    }

    function handleFile(type, input) {
      const file = input.files[0];
      if (!file) return;
      const box = document.getElementById(type + '-box');
      const icon = document.getElementById(type + '-icon');
      const nameEl = document.getElementById(type + '-name');

      if (file.name.endsWith('.csv')) {
        Papa.parse(file, {
          header: true, skipEmptyLines: true,
          complete: (results) => { files[type] = { name: file.name, data: results.data }; box.classList.add('uploaded'); icon.textContent = '‚úì'; nameEl.textContent = file.name; updateContinueButton(); },
          error: (err) => showError('Error parsing ' + file.name)
        });
      } else {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const wb = XLSX.read(e.target.result, { type: 'array', cellDates: true });
            const data = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { raw: false, dateNF: 'yyyy-mm-dd' });
            files[type] = { name: file.name, data: data }; box.classList.add('uploaded'); icon.textContent = '‚úì'; nameEl.textContent = file.name; updateContinueButton();
          } catch (err) { showError('Error parsing ' + file.name); }
        };
        reader.readAsArrayBuffer(file);
      }
    }

    function handleCompsets(input) {
      Array.from(input.files).forEach(file => {
        Papa.parse(file, {
          header: true, skipEmptyLines: true,
          complete: (results) => { files.compsets.push({ name: file.name, data: results.data }); renderCompsetList(); },
          error: (err) => showError('Error parsing ' + file.name)
        });
      });
    }

    function removeCompset(index) { files.compsets.splice(index, 1); renderCompsetList(); }
    function renderCompsetList() { document.getElementById('compset-list').innerHTML = files.compsets.map((cs, i) => '<div class="compset-chip">' + cs.name + '<button onclick="removeCompset(' + i + ')">√ó</button></div>').join(''); }

    function goToStep(step) {
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.querySelectorAll('.progress-step').forEach(s => s.classList.remove('active'));
      document.getElementById('step' + step).classList.add('active');
      for (let i = 1; i <= step; i++) document.getElementById('step' + i + '-indicator').classList.add('active');
      if (step === 2) {
        document.getElementById('files-summary').innerHTML = [
          '‚úì ' + files.listings.name + ' (' + files.listings.data.length + ' listings)',
          '‚úì ' + files.revenue.name + ' (' + files.revenue.data.length + ' revenue records)',
          '‚úì ' + files.bookings.name + ' (' + files.bookings.data.length + ' bookings)',
          '‚úì ' + files.market.name + ' (' + files.market.data.length + ' market records)',
          '‚úì ' + files.compsets.length + ' compset file(s)'
        ].map(s => '<li>' + s + '</li>').join('');
      }
    }

    function parseDate(dateStr) {
      if (!dateStr) return null;
      if (dateStr instanceof Date) return dateStr;
      let d = new Date(dateStr);
      if (!isNaN(d)) return d;
      const parts = dateStr.split(/[-\/]/);
      if (parts.length === 3) {
        if (parts[0].length === 4) d = new Date(parts[0], parts[1] - 1, parts[2]);
        else d = new Date(parts[2], parts[0] - 1, parts[1]);
        if (!isNaN(d)) return d;
      }
      return null;
    }

    function runAnalysis() {
      const btn = document.getElementById('analyze-btn');
      btn.innerHTML = '<span class="loading"></span>Analyzing...';
      btn.disabled = true;

      setTimeout(() => {
        try {
          const portfolioName = document.getElementById('portfolio-name').value || 'Portfolio';
          const listingsData = files.listings.data;
          const revenueData = files.revenue.data;
          const marketData = files.market.data;
          const bookingsData = files.bookings.data;

          const portfolioIds = new Set();
          const bedroomLookup = {}, nameLookup = {};
          
          listingsData.forEach(l => {
            const id = getVal(l, 'ListingID', 'Listing ID', 'listing_id', 'listingId');
            if (!id) return;
            const idStr = String(id).trim();
            portfolioIds.add(idStr);
            bedroomLookup[idStr] = parseInt(getVal(l, 'Bedrooms', 'BR', 'BR Count', 'bedrooms')) || 0;
            nameLookup[idStr] = getVal(l, 'Listing', 'Listing Name', 'listing_name', 'Name') || 'Unknown';
          });

          const compsetByBedroom = {};
          files.compsets.forEach(cs => {
            if (cs.data && cs.data.length > 0) {
              const bedrooms = parseInt(getVal(cs.data[0], 'Bedrooms', 'BR')) || 0;
              const revenues = cs.data.map(r => parseFloat(getVal(r, 'Revenue', 'revenue')) || 0).filter(r => r > 0);
              if (revenues.length > 0) {
                if (bedrooms >= 5) { for (let b = 5; b <= 10; b++) compsetByBedroom[b] = (compsetByBedroom[b] || []).concat(revenues); }
                else compsetByBedroom[bedrooms] = revenues;
              }
            }
          });

          const monthMap = { Jan: 1, Feb: 2, Mar: 3, Apr: 4, May: 5, Jun: 6, Jul: 7, Aug: 8, Sep: 9, Oct: 10, Nov: 11, Dec: 12 };
          const t12Months = [202502, 202503, 202504, 202505, 202506, 202507, 202508, 202509, 202510, 202511, 202512, 202601];

          const revenueByListing = {};
          
          revenueData.forEach(row => {
            const listingId = String(getVal(row, 'Listing ID', 'ListingID', 'listing_id') || '').trim();
            if (!portfolioIds.has(listingId)) return;
            
            const monthStr = getVal(row, 'Month', 'month');
            const year = parseInt(getVal(row, 'Year', 'year'));
            const month = monthMap[monthStr];
            if (!month || !year) return;
            
            const yearMonth = year * 100 + month;
            if (!t12Months.includes(yearMonth)) return;
            
            if (!revenueByListing[listingId]) revenueByListing[listingId] = { total: 0, months: [], monthsWithRev: 0 };
            const rev = parseFloat(getVal(row, 'Revenue', 'revenue')) || 0;
            revenueByListing[listingId].total += rev;
            revenueByListing[listingId].months.push({ yearMonth, revenue: rev });
            if (rev > 0) revenueByListing[listingId].monthsWithRev++;
          });

          const marketByYearMonth = {}, marketLyByYearMonth = {};
          marketData.forEach(row => {
            const dateStr = getVal(row, 'Date', 'date');
            const date = parseDate(dateStr);
            if (!date || isNaN(date)) return;
            const yearMonth = date.getFullYear() * 100 + (date.getMonth() + 1);
            if (!marketByYearMonth[yearMonth]) { marketByYearMonth[yearMonth] = []; marketLyByYearMonth[yearMonth] = []; }
            const occ = parseFloat(getVal(row, 'Occupancy', 'occupancy'));
            const lyFinal = getVal(row, 'Occupancy (last year final)', 'Occupancy_LY');
            if (!isNaN(occ)) marketByYearMonth[yearMonth].push(occ);
            if (lyFinal && lyFinal !== 'NA' && !isNaN(parseFloat(lyFinal))) marketLyByYearMonth[yearMonth].push(parseFloat(lyFinal));
          });

          const avgMarketOcc = {}, avgMarketLy = {};
          Object.keys(marketByYearMonth).forEach(ym => { const v = marketByYearMonth[ym]; avgMarketOcc[ym] = v.length ? v.reduce((a, b) => a + b, 0) / v.length : 0; });
          Object.keys(marketLyByYearMonth).forEach(ym => { const v = marketLyByYearMonth[ym]; avgMarketLy[ym] = v.length ? v.reduce((a, b) => a + b, 0) / v.length : null; });

          const seasonality = {};
          let totalSeasonality = 0;
          t12Months.forEach(ym => { const lyYm = ym >= 202600 ? ym - 100 : ym; seasonality[ym] = avgMarketLy[lyYm] || avgMarketLy[ym] || 50; totalSeasonality += seasonality[ym]; });

          const firstPass = [];
          portfolioIds.forEach(listingId => {
            const data = revenueByListing[listingId] || { total: 0, months: [], monthsWithRev: 0 };
            const bedrooms = bedroomLookup[listingId];
            if (data.monthsWithRev >= 6) {
              let projected = data.total;
              if (data.monthsWithRev < 12) {
                const activeMonths = data.months.filter(m => m.revenue > 0).map(m => m.yearMonth);
                const activeSeas = activeMonths.reduce((s, ym) => s + (seasonality[ym] || 50), 0);
                projected = activeSeas > 0 ? data.total * (totalSeasonality / activeSeas) : data.total;
              }
              const compset = compsetByBedroom[bedrooms];
              if (compset && compset.length > 0 && projected > 0) {
                firstPass.push({ percentile: percentileOfScore(compset, projected) });
              }
            }
          });
          const avgPercentile6Plus = firstPass.length > 0 ? firstPass.reduce((s, l) => s + l.percentile, 0) / firstPass.length : 50;

          const listingsAnalysis = [];
          let currentT12 = 0, projectedT12 = 0;

          portfolioIds.forEach(listingId => {
            const data = revenueByListing[listingId] || { total: 0, months: [], monthsWithRev: 0 };
            const bedrooms = bedroomLookup[listingId], name = nameLookup[listingId];
            const monthsCount = data.monthsWithRev, actualRevenue = data.total;
            let projectedRevenue, method;

            if (monthsCount === 12) { projectedRevenue = actualRevenue; method = 'Actual (12 months)'; }
            else if (monthsCount >= 6) {
              const activeMonths = data.months.filter(m => m.revenue > 0).map(m => m.yearMonth);
              const activeSeas = activeMonths.reduce((s, ym) => s + (seasonality[ym] || 50), 0);
              projectedRevenue = activeSeas > 0 ? actualRevenue * (totalSeasonality / activeSeas) : actualRevenue;
              method = 'Seasonality (' + monthsCount + ' months)';
            } else {
              const compset = compsetByBedroom[bedrooms];
              if (compset && compset.length > 0) {
                projectedRevenue = valueAtPercentile(compset, avgPercentile6Plus);
                method = 'Avg Pctl (' + monthsCount + ' mo)';
              } else { projectedRevenue = actualRevenue; method = 'No compset'; }
            }

            let percentile = null;
            const compset = compsetByBedroom[bedrooms];
            if (compset && compset.length > 0 && projectedRevenue > 0) percentile = percentileOfScore(compset, projectedRevenue);

            listingsAnalysis.push({ listingId, name, bedrooms, months: monthsCount, actualRevenue, projectedRevenue, percentile, method });
            currentT12 += actualRevenue;
            projectedT12 += projectedRevenue;
          });

          const units6Plus = listingsAnalysis.filter(l => l.months >= 6 && l.percentile !== null);
          const avgPercentile = units6Plus.length > 0 ? units6Plus.reduce((s, l) => s + l.percentile, 0) / units6Plus.length : 50;

          let percentileGrowth = 0.05;
          if (units6Plus.length > 0) {
            const bedCounts = {};
            units6Plus.forEach(l => { bedCounts[l.bedrooms] = (bedCounts[l.bedrooms] || 0) + 1; });
            let wCurrent = 0, w90 = 0;
            Object.entries(bedCounts).forEach(([bed, count]) => {
              const cs = compsetByBedroom[bed];
              if (cs && cs.length > 0) {
                const sorted = cs.slice().sort((a, b) => a - b);
                wCurrent += (sorted[Math.min(Math.floor((avgPercentile / 100) * sorted.length), sorted.length - 1)] || 0) * count;
                w90 += (sorted[Math.min(Math.floor(0.9 * sorted.length), sorted.length - 1)] || 0) * count;
              }
            });
            if (wCurrent > 0) percentileGrowth = (w90 / wCurrent) - 1;
          }

          const bookingsByListing = {};
          bookingsData.forEach(b => {
            const listingId = String(getVal(b, 'Listing ID', 'ListingID', 'listing_id') || '').trim();
            if (!portfolioIds.has(listingId)) return;
            const checkin = parseDate(getVal(b, 'Check-in Date', 'Check-in', 'Checkin', 'check_in_date'));
            const checkout = parseDate(getVal(b, 'Check-out Date', 'Check-out', 'Checkout', 'check_out_date'));
            if (!checkin || !checkout) return;
            if (!bookingsByListing[listingId]) bookingsByListing[listingId] = [];
            bookingsByListing[listingId].push({ checkin, checkout });
          });

          const countBookedNights = (listingId, year, month) => {
            const bookings = bookingsByListing[listingId] || [];
            const daysInMonth = new Date(year, month, 0).getDate();
            const monthStart = new Date(year, month - 1, 1);
            const monthEnd = new Date(year, month, 0, 23, 59, 59);
            let bookedNights = 0;
            bookings.forEach(b => {
              if (b.checkout <= monthStart || b.checkin > monthEnd) return;
              const start = b.checkin < monthStart ? monthStart : b.checkin;
              const end = b.checkout > new Date(year, month, 1) ? new Date(year, month, 1) : b.checkout;
              const nights = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
              if (nights > 0) bookedNights += nights;
            });
            return { bookedNights, daysInMonth };
          };

          const calcScore = (ratio) => { if (ratio == null) return null; const d = Math.abs(ratio - 1); return d < 0.1 ? 5 : d < 0.25 ? 4 : d < 0.4 ? 3 : d < 0.5 ? 2 : 1; };

          const pacingMonths = [
            { year: 2026, month: 3, name: 'Mar 2026' }, { year: 2026, month: 4, name: 'Apr 2026' },
            { year: 2026, month: 5, name: 'May 2026' }, { year: 2026, month: 6, name: 'Jun 2026' },
            { year: 2026, month: 7, name: 'Jul 2026' }, { year: 2026, month: 8, name: 'Aug 2026' },
            { year: 2026, month: 9, name: 'Sep 2026' }, { year: 2026, month: 10, name: 'Oct 2026' },
            { year: 2026, month: 11, name: 'Nov 2026' }, { year: 2026, month: 12, name: 'Dec 2026' },
          ];

          const lyFinals = Object.values(avgMarketLy).filter(v => v != null && v > 0);
          const avgLyFinal = lyFinals.length > 0 ? lyFinals.reduce((a, b) => a + b, 0) / lyFinals.length : 50;
          const mpit = (26.5 * Math.log(avgLyFinal) - 24) / avgLyFinal - avgLyFinal / 1000;

          const pacingData = [];
          let totalWeight = 0, weightedScoreSum = 0;

          pacingMonths.forEach(pm => {
            const ym = pm.year * 100 + pm.month;
            const mktOcc = (avgMarketOcc[ym] || 0) / 100;
            const mktLy = avgMarketLy[ym] ? avgMarketLy[ym] / 100 : null;

            let totalBooked = 0, totalDays = 0;
            portfolioIds.forEach(lid => { const r = countBookedNights(lid, pm.year, pm.month); totalBooked += r.bookedNights; totalDays += r.daysInMonth; });

            const portOcc = totalDays > 0 ? totalBooked / totalDays : 0;
            const mpi = mktOcc > 0 ? portOcc / mktOcc : 0;
            let mpitMonth = null, ratio = null, score = null;

            if (mktLy && mktLy > 0) {
              const emo = mktLy * 100;
              mpitMonth = (26.5 * Math.log(emo) - 24) / emo - emo / 1000;
              ratio = mpitMonth > 0 ? mpi / mpitMonth : null;
              score = calcScore(ratio);
              if (score != null && mktOcc >= 0.01) { totalWeight += mktOcc; weightedScoreSum += score * mktOcc; }
            }
            pacingData.push({ monthName: pm.name, portOcc, mktOcc, mpi, mktLy, mpit: mpitMonth, ratio, score });
          });

          const pacingScore = totalWeight > 0 ? Math.round((weightedScoreSum / totalWeight) * 100) / 100 : 2.5;

          const listingRatios = [];
          portfolioIds.forEach(lid => {
            const mpis = [];
            pacingMonths.forEach(pm => {
              const ym = pm.year * 100 + pm.month, mktOcc = (avgMarketOcc[ym] || 0) / 100;
              if (mktOcc < 0.01) return;
              const r = countBookedNights(lid, pm.year, pm.month);
              const occ = r.daysInMonth > 0 ? r.bookedNights / r.daysInMonth : 0;
              if (mktOcc > 0) mpis.push(occ / mktOcc);
            });
            if (mpis.length > 0) listingRatios.push(mpit > 0 ? mpis.reduce((a, b) => a + b, 0) / mpis.length / mpit : 0);
          });

          let coeffVar = 0.5, consistencyScore = 3;
          if (listingRatios.length > 2) {
            const sorted = listingRatios.slice().sort((a, b) => a - b);
            const filtered = sorted.slice(Math.floor(0.05 * sorted.length), Math.floor(0.95 * sorted.length) + 1);
            if (filtered.length > 0) {
              const mean = filtered.reduce((a, b) => a + b, 0) / filtered.length;
              const variance = filtered.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / filtered.length;
              coeffVar = mean > 0 ? Math.sqrt(variance) / mean : 0.5;
            }
          }
          consistencyScore = coeffVar < 0.4 ? 5 : coeffVar < 0.6 ? 4 : coeffVar < 0.8 ? 3 : coeffVar < 1 ? 2 : 1;

          const avgScore = (pacingScore + consistencyScore) / 2;
          const pacingGrowth = 0.20 - ((avgScore - 1) * 0.05);
          const rpmGrowth = (pacingGrowth + percentileGrowth) / 2;

          const marketOccByMonth = pacingMonths.map(pm => (avgMarketOcc[pm.year * 100 + pm.month] || 0) / 100);
          const avgMarketOccVal = marketOccByMonth.reduce((a, b) => a + b, 0) / marketOccByMonth.length;

          const listingPacingData = [];
          portfolioIds.forEach(lid => {
            const name = nameLookup[lid], bedrooms = bedroomLookup[lid];
            const monthlyOcc = pacingMonths.map(pm => { const r = countBookedNights(lid, pm.year, pm.month); return r.daysInMonth > 0 ? r.bookedNights / r.daysInMonth : 0; });
            const monthlyMpi = monthlyOcc.map((o, i) => marketOccByMonth[i] > 0 ? o / marketOccByMonth[i] : null);
            const validMpis = monthlyMpi.filter(m => m != null);
            const avgOcc = monthlyOcc.reduce((a, b) => a + b, 0) / monthlyOcc.length;
            const avgMpi = validMpis.length > 0 ? validMpis.reduce((a, b) => a + b, 0) / validMpis.length : null;
            const mpiMpitRatio = avgMpi != null && mpit > 0 ? avgMpi / mpit : null;
            listingPacingData.push({ name, bedrooms, monthlyOcc, avgOcc, avgMpi, mpit, mpiMpitRatio });
          });
          listingPacingData.sort((a, b) => a.name.localeCompare(b.name));

          const feeInfo = getFeeRate(projectedT12);
          const newProjectedRevenue = projectedT12 * (1 + rpmGrowth);
          const rpmFee = newProjectedRevenue * feeInfo.rate;

          analysis = {
            portfolioName, currentT12: roundTo100k(currentT12), projectedT12: roundTo100k(projectedT12),
            avgPercentile: Math.round(avgPercentile), pacingScore, consistencyScore,
            avgScore: Math.round(avgScore * 100) / 100, coeffVar: Math.round(coeffVar * 100),
            rpmGrowth: Math.round(rpmGrowth * 100), rpmRate: feeInfo.rate,
            newProjectedRevenue: roundTo5k(newProjectedRevenue), rpmFee: roundTo1k(rpmFee),
            newNetRevenue: roundTo1k(newProjectedRevenue - projectedT12 - rpmFee),
            listingsAnalysis, units6PlusCount: units6Plus.length, totalUnits: listingsAnalysis.length,
            pacingData, listingPacingData, marketOccByMonth, avgMarketOcc: avgMarketOccVal, mpit
          };

          renderResults();
          goToStep(3);
        } catch (err) { console.error(err); showError(err.message); }
        finally { btn.innerHTML = 'Run Analysis ‚Üí'; btn.disabled = false; }
      }, 100);
    }

    function renderResults() {
      document.getElementById('results-grid').innerHTML = [
        { label: 'Current T-12', value: formatCurrency(analysis.currentT12), class: 'highlight' },
        { label: 'Full Potential', value: formatCurrency(analysis.projectedT12), class: 'highlight' },
        { label: 'RPM Growth', value: analysis.rpmGrowth + '%', class: 'accent' },
        { label: 'New Projected Revenue', value: formatCurrency(analysis.newProjectedRevenue), class: 'accent' },
        { label: 'RPM Fee (' + (analysis.rpmRate * 100).toFixed(2) + '%)', value: formatCurrency(analysis.rpmFee), class: '' },
        { label: 'Net Revenue Gain', value: formatCurrency(analysis.newNetRevenue), class: 'success' },
      ].map(r => '<div class="result-card ' + r.class + '"><div class="card-label">' + r.label + '</div><div class="card-value">' + r.value + '</div></div>').join('');

      document.getElementById('scores-grid').innerHTML = [
        { label: 'Pacing Score', value: analysis.pacingScore.toFixed(2) },
        { label: 'Consistency Score', value: analysis.consistencyScore },
        { label: 'Average Score', value: analysis.avgScore },
        { label: 'Avg Percentile (6+ mo)', value: analysis.avgPercentile + '%' },
      ].map(s => '<div class="score-item"><div class="score-label">' + s.label + '</div><div class="score-value">' + s.value + '</div></div>').join('');

      document.getElementById('unit-summary-text').textContent = analysis.totalUnits + ' total units ‚Ä¢ ' + analysis.units6PlusCount + ' with 6+ months data';
    }

    async function generateExcel() {
      const workbook = new ExcelJS.Workbook();
      workbook.creator = 'Freewyld Foundry';
      workbook.created = new Date();

      // Colors
      const headerFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF2E5A3D' } };
      const headerFont = { bold: true, color: { argb: 'FFFFFFFF' }, size: 11 };
      const titleFont = { bold: true, size: 14, color: { argb: 'FF2E5A3D' } };
      const sectionFont = { bold: true, size: 12, color: { argb: 'FF2E5A3D' } };
      const borderStyle = { style: 'thin', color: { argb: 'FFD0D0D0' } };
      const allBorders = { top: borderStyle, left: borderStyle, bottom: borderStyle, right: borderStyle };

      // ========== DASHBOARD ==========
      const dash = workbook.addWorksheet('Dashboard');
      dash.columns = [{ width: 32 }, { width: 20 }, { width: 18 }, { width: 16 }];

      dash.getCell('A1').value = 'Portfolio Dashboard - ' + analysis.portfolioName;
      dash.getCell('A1').font = { bold: true, size: 18, color: { argb: 'FF2E5A3D' } };
      dash.mergeCells('A1:D1');

      dash.getCell('A3').value = 'Revenue Summary';
      dash.getCell('A3').font = sectionFont;

      const revSummaryData = [
        ['Metric', 'Value'],
        ['Current T-12 Revenue', analysis.currentT12],
        ['Current Full Potential Revenue', analysis.projectedT12],
      ];
      revSummaryData.forEach((row, i) => {
        const r = dash.getRow(4 + i);
        r.values = row;
        if (i === 0) { r.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; }); }
        else { r.eachCell((c, colNum) => { c.border = allBorders; if (colNum === 2) c.numFmt = '"$"#,##0'; }); }
      });

      dash.getCell('A8').value = 'RPM Growth Projection';
      dash.getCell('A8').font = sectionFont;

      const rpmData = [
        ['Metric', 'Value'],
        ['RPM Growth %', analysis.rpmGrowth / 100],
        ['RPM Fee Rate', analysis.rpmRate],
        ['RPM Fee (Annual)', analysis.rpmFee],
        ['New Projected Revenue', analysis.newProjectedRevenue],
        ['New Net Revenue (Growth - Fee)', analysis.newNetRevenue],
      ];
      rpmData.forEach((row, i) => {
        const r = dash.getRow(9 + i);
        r.values = row;
        if (i === 0) { r.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; }); }
        else { 
          r.eachCell((c, colNum) => { 
            c.border = allBorders; 
            if (colNum === 2) {
              if (i <= 2) c.numFmt = '0.0%';
              else c.numFmt = '"$"#,##0';
            }
          }); 
        }
      });

      dash.getCell('A16').value = 'Units with 6+ Months Data';
      dash.getCell('A16').font = sectionFont;

      const bedStats = {};
      analysis.listingsAnalysis.filter(l => l.months >= 6).forEach(l => {
        if (!bedStats[l.bedrooms]) bedStats[l.bedrooms] = { count: 0, revenue: 0, pcts: [] };
        bedStats[l.bedrooms].count++; bedStats[l.bedrooms].revenue += l.projectedRevenue;
        if (l.percentile) bedStats[l.bedrooms].pcts.push(l.percentile);
      });

      const bedData = [['Bedrooms', 'Units', 'Avg Projected Rev', 'Avg Percentile']];
      Object.keys(bedStats).sort((a,b)=>a-b).forEach(bed => {
        const s = bedStats[bed];
        bedData.push([bed + ' BR', s.count, s.revenue / s.count, s.pcts.length ? s.pcts.reduce((a,b)=>a+b,0) / s.pcts.length / 100 : null]);
      });
      const u6 = analysis.listingsAnalysis.filter(l => l.months >= 6);
      const allP = u6.filter(l => l.percentile).map(l => l.percentile);
      bedData.push(['Total', u6.length, u6.reduce((s,l)=>s+l.projectedRevenue,0)/(u6.length||1), allP.length ? allP.reduce((a,b)=>a+b,0)/allP.length/100 : null]);

      bedData.forEach((row, i) => {
        const r = dash.getRow(17 + i);
        r.values = row;
        if (i === 0) { r.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; }); }
        else { 
          r.eachCell((c, colNum) => { 
            c.border = allBorders; 
            if (colNum === 3) c.numFmt = '"$"#,##0';
            if (colNum === 4 && c.value !== null) c.numFmt = '0%';
          }); 
        }
      });

      const pacingStartRow = 17 + bedData.length + 2;
      dash.getCell('A' + pacingStartRow).value = 'Pacing Scores';
      dash.getCell('A' + pacingStartRow).font = sectionFont;

      const pacingScoreData = [
        ['Metric', 'Value', 'Score'],
        ['Pacing Score', 'Weighted Avg MPI/MPIT', analysis.pacingScore],
        ['Consistency Score', 'CV: ' + analysis.coeffVar + '%', analysis.consistencyScore],
        ['Average Score', '', analysis.avgScore],
      ];
      pacingScoreData.forEach((row, i) => {
        const r = dash.getRow(pacingStartRow + 1 + i);
        r.values = row;
        if (i === 0) { r.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; }); }
        else { r.eachCell(c => { c.border = allBorders; }); }
      });

      // ========== T-12 REVENUE ==========
      const rev = workbook.addWorksheet('T-12 Revenue');
      rev.columns = [{ width: 55 }, { width: 6 }, { width: 10 }, { width: 16 }, { width: 18 }, { width: 22 }, { width: 12 }];

      rev.getCell('A1').value = 'T-12 Revenue Analysis (Feb 2025 - Jan 2026)';
      rev.getCell('A1').font = titleFont;
      rev.mergeCells('A1:G1');

      const revHeaders = ['Listing Name', 'BR', 'Months', 'Actual Revenue', 'Projected Revenue', 'Method', 'Percentile'];
      const revHeaderRow = rev.getRow(3);
      revHeaderRow.values = revHeaders;
      revHeaderRow.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; });

      const sortedListings = [...analysis.listingsAnalysis].sort((a,b) => b.months - a.months || a.name.localeCompare(b.name));
      sortedListings.forEach((l, i) => {
        const r = rev.getRow(4 + i);
        r.values = [l.name, l.bedrooms, l.months, l.actualRevenue, Math.round(l.projectedRevenue), l.method, l.percentile ? l.percentile / 100 : 'N/A'];
        r.eachCell((c, colNum) => {
          c.border = allBorders;
          if (colNum === 4 || colNum === 5) c.numFmt = '"$"#,##0';
          if (colNum === 7 && typeof c.value === 'number') c.numFmt = '0%';
        });
      });

      const totalRow = rev.getRow(4 + sortedListings.length);
      totalRow.values = ['Total', '', '', analysis.listingsAnalysis.reduce((s,l)=>s+l.actualRevenue,0), analysis.listingsAnalysis.reduce((s,l)=>s+l.projectedRevenue,0), '', ''];
      totalRow.eachCell((c, colNum) => {
        c.border = allBorders;
        c.font = { bold: true };
        if (colNum === 4 || colNum === 5) c.numFmt = '"$"#,##0';
      });

      // ========== OCCUPANCY PACING ==========
      const pac = workbook.addWorksheet('Occupancy Pacing');
      pac.columns = Array(8).fill({ width: 14 });
      pac.getColumn(1).width = 12;

      pac.getCell('A1').value = 'Portfolio Occupancy Pacing (Mar-Dec 2026)';
      pac.getCell('A1').font = titleFont;
      pac.mergeCells('A1:H1');

      const pacHeaders = ['Month', 'Portfolio Occ', 'Market Occ', 'MPI', 'Market LY', 'MPIT', 'MPI/MPIT', 'Score'];
      const pacHeaderRow = pac.getRow(3);
      pacHeaderRow.values = pacHeaders;
      pacHeaderRow.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; });

      analysis.pacingData.forEach((d, i) => {
        const r = pac.getRow(4 + i);
        r.values = [d.monthName, d.portOcc, d.mktOcc, d.mpi, d.mktLy ?? 'N/A', d.mpit ?? 'N/A', d.ratio ?? 'N/A', d.score ?? 'N/A'];
        r.eachCell((c, colNum) => {
          c.border = allBorders;
          if ([2, 3, 5].includes(colNum) && typeof c.value === 'number') c.numFmt = '0.0%';
          if ([4, 6, 7].includes(colNum) && typeof c.value === 'number') c.numFmt = '0%';
        });
      });

      const pacTotalRow = pac.getRow(4 + analysis.pacingData.length);
      pacTotalRow.values = ['Weighted Average', '', '', '', '', '', '', analysis.pacingScore];
      pacTotalRow.eachCell(c => { c.border = allBorders; c.font = { bold: true }; });

      // ========== LISTING PACING ==========
      const lp = workbook.addWorksheet('Listing Pacing');
      const months = ['Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      lp.columns = [{ width: 55 }, { width: 5 }, ...Array(months.length + 4).fill({ width: 9 })];

      lp.getCell('A1').value = 'Listing Pacing - Forward Occupancy (Mar-Dec 2026)';
      lp.getCell('A1').font = titleFont;
      lp.mergeCells('A1:P1');

      const lpHeaders = ['Listing Name', 'BR', ...months, 'Avg Occ', 'Avg MPI', 'MPIT', 'MPI/MPIT'];
      const lpHeaderRow = lp.getRow(3);
      lpHeaderRow.values = lpHeaders;
      lpHeaderRow.eachCell(c => { c.fill = headerFill; c.font = headerFont; c.border = allBorders; });

      // Market row
      const mktRow = lp.getRow(4);
      mktRow.values = ['Market Occupancy', '', ...analysis.marketOccByMonth, analysis.avgMarketOcc, '', '', ''];
      mktRow.eachCell((c, colNum) => {
        c.border = allBorders;
        c.font = { italic: true };
        if (colNum >= 3 && colNum <= 12 && typeof c.value === 'number') c.numFmt = '0.0%';
        if (colNum === 13 && typeof c.value === 'number') c.numFmt = '0.0%';
      });

      analysis.listingPacingData.forEach((l, i) => {
        const r = lp.getRow(5 + i);
        r.values = [l.name, l.bedrooms, ...l.monthlyOcc, l.avgOcc, l.avgMpi, l.mpit, l.mpiMpitRatio];
        r.eachCell((c, colNum) => {
          c.border = allBorders;
          if (colNum >= 3 && colNum <= 13 && typeof c.value === 'number') c.numFmt = '0.0%';
          if (colNum >= 14 && typeof c.value === 'number') c.numFmt = '0%';
        });
      });

      // Portfolio average row
      const avgRow = lp.getRow(5 + analysis.listingPacingData.length);
      const avgValues = ['Portfolio Average', ''];
      for (let col = 0; col < months.length + 4; col++) {
        const colLetter = String.fromCharCode(67 + col); // C, D, E, ...
        const lastDataRow = 4 + analysis.listingPacingData.length;
        avgValues.push({ formula: `AVERAGE(${colLetter}5:${colLetter}${lastDataRow})` });
      }
      avgRow.values = avgValues;
      avgRow.eachCell((c, colNum) => {
        c.border = allBorders;
        c.font = { bold: true };
        if (colNum >= 3 && colNum <= 13) c.numFmt = '0.0%';
        if (colNum >= 14) c.numFmt = '0%';
      });

      // Generate and download
      const buffer = await workbook.xlsx.writeBuffer();
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = analysis.portfolioName.replace(/\s+/g, '_') + '_T12_Revenue.xlsx';
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
