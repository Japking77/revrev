<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio Revenue Analyzer - Freewyld Foundry</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { min-height: 100vh; background: linear-gradient(135deg, #0a0f0d 0%, #1a2f23 50%, #0d1a14 100%); color: #e8f0eb; font-family: 'DM Sans', sans-serif; padding: 40px 20px; }
    .header { text-align: center; margin-bottom: 48px; }
    .logo { display: inline-flex; align-items: center; gap: 12px; margin-bottom: 24px; padding: 12px 24px; background: rgba(46, 90, 61, 0.3); border: 1px solid rgba(46, 90, 61, 0.5); border-radius: 100px; }
    .logo-icon { font-size: 24px; color: #7cb88c; }
    .logo-text { font-family: 'Space Mono', monospace; font-weight: 700; font-size: 14px; letter-spacing: 2px; text-transform: uppercase; color: #7cb88c; }
    h1 { font-size: 48px; font-weight: 700; margin-bottom: 12px; background: linear-gradient(135deg, #e8f0eb 0%, #7cb88c 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .subtitle { font-size: 18px; color: #8aa894; max-width: 600px; margin: 0 auto; }
    .progress-bar { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 48px; }
    .progress-step { display: flex; align-items: center; gap: 8px; opacity: 0.4; transition: opacity 0.3s; }
    .progress-step.active { opacity: 1; }
    .step-number { width: 32px; height: 32px; border-radius: 50%; background: rgba(46, 90, 61, 0.5); border: 2px solid #2e5a3d; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
    .progress-step.active .step-number { background: #2e5a3d; border-color: #7cb88c; }
    .step-label { font-size: 14px; font-weight: 500; }
    .progress-line { width: 60px; height: 2px; background: rgba(46, 90, 61, 0.5); }
    .error-banner { max-width: 800px; margin: 0 auto 24px; padding: 16px 24px; background: rgba(180, 60, 60, 0.2); border: 1px solid rgba(180, 60, 60, 0.5); border-radius: 12px; display: none; align-items: center; gap: 12px; }
    .error-banner.show { display: flex; }
    .error-icon { font-size: 20px; }
    .error-banner button { margin-left: auto; background: none; border: none; color: #e8f0eb; font-size: 20px; cursor: pointer; }
    .section { max-width: 900px; margin: 0 auto; background: rgba(20, 35, 28, 0.8); border: 1px solid rgba(46, 90, 61, 0.3); border-radius: 24px; padding: 40px; backdrop-filter: blur(10px); display: none; }
    .section.active { display: block; }
    h2 { font-size: 28px; margin-bottom: 32px; color: #e8f0eb; }
    h3 { font-size: 18px; margin-bottom: 16px; color: #8aa894; }
    .help-text { font-size: 14px; color: #6a8a74; margin-bottom: 12px; }
    .upload-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 32px; }
    .upload-box { position: relative; padding: 32px; border: 2px dashed rgba(46, 90, 61, 0.5); border-radius: 16px; text-align: center; cursor: pointer; transition: all 0.3s; background: rgba(46, 90, 61, 0.1); }
    .upload-box:hover { border-color: #7cb88c; background: rgba(46, 90, 61, 0.2); }
    .upload-box.uploaded { border-color: #7cb88c; border-style: solid; background: rgba(46, 90, 61, 0.2); }
    .upload-box input { position: absolute; inset: 0; opacity: 0; cursor: pointer; }
    .upload-icon { font-size: 32px; margin-bottom: 12px; color: #7cb88c; }
    .upload-label { font-weight: 600; margin-bottom: 8px; }
    .required { color: #b88c7c; margin-left: 4px; }
    .file-name { font-size: 12px; color: #7cb88c; font-family: 'Space Mono', monospace; margin-top: 8px; word-break: break-all; }
    .compset-section { margin-bottom: 32px; }
    .compset-upload { padding: 24px; border: 2px dashed rgba(46, 90, 61, 0.5); border-radius: 16px; background: rgba(46, 90, 61, 0.1); }
    .compset-upload input { margin-bottom: 16px; }
    .compset-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px; }
    .compset-chip { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; background: rgba(46, 90, 61, 0.3); border-radius: 100px; font-size: 13px; font-family: 'Space Mono', monospace; }
    .compset-chip button { background: none; border: none; color: #8aa894; cursor: pointer; font-size: 16px; }
    .primary-btn, .secondary-btn { padding: 16px 32px; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; border: none; }
    .primary-btn { background: linear-gradient(135deg, #2e5a3d 0%, #3d7a52 100%); color: #e8f0eb; box-shadow: 0 4px 20px rgba(46, 90, 61, 0.4); }
    .primary-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 24px rgba(46, 90, 61, 0.6); }
    .primary-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .secondary-btn { background: transparent; color: #8aa894; border: 2px solid rgba(46, 90, 61, 0.5); }
    .secondary-btn:hover { border-color: #7cb88c; color: #e8f0eb; }
    .btn-group { display: flex; gap: 16px; justify-content: center; margin-top: 32px; }
    .config-form { margin-bottom: 32px; }
    .config-form label { display: block; margin-bottom: 24px; font-weight: 500; }
    .config-form input[type="text"] { width: 100%; margin-top: 8px; padding: 16px; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(46, 90, 61, 0.5); border-radius: 12px; color: #e8f0eb; font-size: 16px; font-family: 'DM Sans', sans-serif; }
    .config-form input[type="text"]:focus { outline: none; border-color: #7cb88c; }
    .file-summary { padding: 24px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; }
    .file-summary ul { list-style: none; }
    .file-summary li { padding: 8px 0; font-family: 'Space Mono', monospace; font-size: 13px; color: #7cb88c; }
    .results-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; margin-bottom: 32px; }
    .result-card { padding: 24px; background: rgba(0, 0, 0, 0.3); border-radius: 16px; border: 1px solid rgba(46, 90, 61, 0.3); }
    .result-card.highlight { background: rgba(46, 90, 61, 0.2); border-color: rgba(46, 90, 61, 0.5); }
    .result-card.accent { background: rgba(124, 184, 140, 0.1); border-color: rgba(124, 184, 140, 0.3); }
    .result-card.success { background: linear-gradient(135deg, rgba(46, 90, 61, 0.3) 0%, rgba(124, 184, 140, 0.2) 100%); border-color: #7cb88c; }
    .card-label { font-size: 13px; color: #8aa894; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
    .card-value { font-size: 28px; font-weight: 700; font-family: 'Space Mono', monospace; }
    .result-card.success .card-value { color: #7cb88c; }
    .scores-section { margin-bottom: 24px; }
    .scores-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; }
    .score-item { padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; text-align: center; }
    .score-label { font-size: 12px; color: #8aa894; margin-bottom: 8px; }
    .score-value { font-size: 24px; font-weight: 700; font-family: 'Space Mono', monospace; color: #7cb88c; }
    .unit-summary { padding: 20px; background: rgba(0, 0, 0, 0.2); border-radius: 12px; text-align: center; margin-bottom: 24px; }
    .unit-summary p { color: #8aa894; margin-top: 8px; }
    .export-info { padding: 24px; background: rgba(46, 90, 61, 0.15); border: 1px solid rgba(46, 90, 61, 0.3); border-radius: 12px; margin-bottom: 24px; }
    .export-info ul { list-style: none; }
    .export-info li { padding: 8px 0; color: #8aa894; }
    .export-info strong { color: #e8f0eb; }
    .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-right: 10px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @media (max-width: 768px) { .upload-grid { grid-template-columns: 1fr; } .results-grid { grid-template-columns: 1fr; } .scores-grid { grid-template-columns: repeat(2, 1fr); } h1 { font-size: 32px; } }
  </style>
</head>
<body>
  <div class="header">
    <div class="logo"><span class="logo-icon">‚óÜ</span><span class="logo-text">Freewyld Foundry</span></div>
    <h1>Portfolio Revenue Analyzer</h1>
    <p class="subtitle">Upload your data to generate comprehensive T-12 revenue analysis with formatted Excel export</p>
  </div>

  <div class="progress-bar">
    <div class="progress-step active" id="step1-indicator"><div class="step-number">1</div><div class="step-label">Upload Files</div></div>
    <div class="progress-line"></div>
    <div class="progress-step" id="step2-indicator"><div class="step-number">2</div><div class="step-label">Configure</div></div>
    <div class="progress-line"></div>
    <div class="progress-step" id="step3-indicator"><div class="step-number">3</div><div class="step-label">Results</div></div>
  </div>

  <div class="error-banner" id="error-banner">
    <span class="error-icon">‚ö†</span>
    <span id="error-message"></span>
    <button onclick="hideError()">√ó</button>
  </div>

  <!-- Step 1: Upload Files -->
  <div class="section active" id="step1">
    <h2>Upload Portfolio Data</h2>
    <div class="upload-grid">
      <div class="upload-box" id="listings-box">
        <div class="upload-icon" id="listings-icon">‚Üë</div>
        <div class="upload-label">Portfolio Listings<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('listings', this)">
        <div class="file-name" id="listings-name"></div>
      </div>
      <div class="upload-box" id="revenue-box">
        <div class="upload-icon" id="revenue-icon">‚Üë</div>
        <div class="upload-label">Historic Revenue<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('revenue', this)">
        <div class="file-name" id="revenue-name"></div>
      </div>
      <div class="upload-box" id="bookings-box">
        <div class="upload-icon" id="bookings-icon">‚Üë</div>
        <div class="upload-label">Bookings Report<span class="required">*</span></div>
        <input type="file" accept=".xlsx,.xls,.csv" onchange="handleFile('bookings', this)">
        <div class="file-name" id="bookings-name"></div>
      </div>
      <div class="upload-box" id="market-box">
        <div class="upload-icon" id="market-icon">‚Üë</div>
        <div class="upload-label">Market Occupancy<span class="required">*</span></div>
        <input type="file" accept=".csv" onchange="handleFile('market', this)">
        <div class="file-name" id="market-name"></div>
      </div>
    </div>
    <div class="compset-section">
      <h3>Compset Files (by bedroom)</h3>
      <p class="help-text">Upload one CSV file per bedroom type with Revenue and Bedrooms columns.</p>
      <div class="compset-upload">
        <input type="file" accept=".csv" multiple onchange="handleCompsets(this)">
        <div class="compset-list" id="compset-list"></div>
      </div>
    </div>
    <button class="primary-btn" id="continue-btn" onclick="goToStep(2)" disabled>Continue ‚Üí</button>
  </div>

  <!-- Step 2: Configure -->
  <div class="section" id="step2">
    <h2>Configure Analysis</h2>
    <div class="config-form">
      <label>Portfolio Name<input type="text" id="portfolio-name" value="Portfolio" placeholder="e.g., West Palm Beach"></label>
      <div class="file-summary">
        <h3>Files Loaded</h3>
        <ul id="files-summary"></ul>
      </div>
    </div>
    <div class="btn-group">
      <button class="secondary-btn" onclick="goToStep(1)">‚Üê Back</button>
      <button class="primary-btn" id="analyze-btn" onclick="runAnalysis()">Run Analysis ‚Üí</button>
    </div>
  </div>

  <!-- Step 3: Results -->
  <div class="section" id="step3">
    <h2>Analysis Results</h2>
    <div class="results-grid" id="results-grid"></div>
    <div class="scores-section">
      <h3>Pacing Scores</h3>
      <div class="scores-grid" id="scores-grid"></div>
    </div>
    <div class="unit-summary"><h3>Unit Summary</h3><p id="unit-summary-text"></p></div>
    <div class="export-info">
      <h3>Excel Export Includes</h3>
      <ul>
        <li>üìä <strong>Dashboard</strong> - Revenue summary, RPM projections, pacing scores</li>
        <li>üìà <strong>T-12 Revenue</strong> - All listings with actual/projected revenue and percentiles</li>
        <li>üìÖ <strong>Occupancy Pacing</strong> - Monthly MPI vs MPIT analysis</li>
        <li>üè† <strong>Listing Pacing</strong> - Individual unit forward occupancy</li>
      </ul>
    </div>
    <div class="btn-group">
      <button class="secondary-btn" onclick="goToStep(1)">‚Üê Start Over</button>
      <button class="primary-btn" onclick="generateExcel()">‚Üì Download Excel Report</button>
    </div>
  </div>

  <script>
    // Global state
    const files = { listings: null, revenue: null, bookings: null, market: null, compsets: [] };
    let analysis = null;

    // Fee tiers
    const FEE_TIERS = [
      { min: 0, max: 2000000, rate: 0.03, tier: "$1M-$2M" },
      { min: 2000000, max: 3000000, rate: 0.025, tier: "$2M-$3M" },
      { min: 3000000, max: 4000000, rate: 0.02, tier: "$3M-$4M" },
      { min: 4000000, max: 5000000, rate: 0.0175, tier: "$4M-$5M" },
      { min: 5000000, max: 7000000, rate: 0.016, tier: "$5M-$7M" },
      { min: 7000000, max: 9000000, rate: 0.014, tier: "$7M-$9M" },
      { min: 9000000, max: 12000000, rate: 0.0125, tier: "$9M-$12M" },
      { min: 12000000, max: 15000000, rate: 0.011, tier: "$12M-$15M" },
      { min: 15000000, max: Infinity, rate: 0.01, tier: "$15M+" },
    ];

    const getFeeRate = (revenue) => FEE_TIERS.find(t => revenue >= t.min && revenue < t.max) || FEE_TIERS[0];
    const roundTo100k = (v) => Math.round(v / 100000) * 100000;
    const roundTo5k = (v) => Math.round(v / 5000) * 5000;
    const roundTo1k = (v) => Math.round(v / 1000) * 1000;
    const formatCurrency = (val) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(val);
    
    const percentileOfScore = (arr, value) => {
      const sorted = [...arr].sort((a, b) => a - b);
      return (sorted.filter(v => v <= value).length / sorted.length) * 100;
    };
    
    // Get value at a given percentile from an array
    const valueAtPercentile = (arr, percentile) => {
      const sorted = [...arr].sort((a, b) => a - b);
      const index = Math.min(Math.floor((percentile / 100) * sorted.length), sorted.length - 1);
      return sorted[index];
    };

    function showError(msg) {
      document.getElementById('error-message').textContent = msg;
      document.getElementById('error-banner').classList.add('show');
    }

    function hideError() {
      document.getElementById('error-banner').classList.remove('show');
    }

    function updateContinueButton() {
      const btn = document.getElementById('continue-btn');
      btn.disabled = !(files.listings && files.revenue && files.market && files.bookings);
    }

    function handleFile(type, input) {
      const file = input.files[0];
      if (!file) return;

      const box = document.getElementById(type + '-box');
      const icon = document.getElementById(type + '-icon');
      const nameEl = document.getElementById(type + '-name');

      if (file.name.endsWith('.csv')) {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            files[type] = { name: file.name, data: results.data };
            box.classList.add('uploaded');
            icon.textContent = '‚úì';
            nameEl.textContent = file.name;
            updateContinueButton();
          },
          error: (err) => showError('Error parsing ' + file.name + ': ' + err.message)
        });
      } else {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const wb = XLSX.read(e.target.result, { type: 'array', cellDates: true });
            const data = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { raw: false, dateNF: 'yyyy-mm-dd' });
            files[type] = { name: file.name, data: data };
            box.classList.add('uploaded');
            icon.textContent = '‚úì';
            nameEl.textContent = file.name;
            updateContinueButton();
          } catch (err) { showError('Error parsing ' + file.name + ': ' + err.message); }
        };
        reader.readAsArrayBuffer(file);
      }
    }

    function handleCompsets(input) {
      Array.from(input.files).forEach(file => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            files.compsets.push({ name: file.name, data: results.data });
            renderCompsetList();
          },
          error: (err) => showError('Error parsing ' + file.name + ': ' + err.message)
        });
      });
    }

    function removeCompset(index) {
      files.compsets.splice(index, 1);
      renderCompsetList();
    }

    function renderCompsetList() {
      const list = document.getElementById('compset-list');
      list.innerHTML = files.compsets.map((cs, i) => 
        '<div class="compset-chip">' + cs.name + '<button onclick="removeCompset(' + i + ')">√ó</button></div>'
      ).join('');
    }

    function goToStep(step) {
      document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
      document.querySelectorAll('.progress-step').forEach(s => s.classList.remove('active'));
      
      document.getElementById('step' + step).classList.add('active');
      for (let i = 1; i <= step; i++) {
        document.getElementById('step' + i + '-indicator').classList.add('active');
      }

      if (step === 2) {
        const summary = document.getElementById('files-summary');
        summary.innerHTML = [
          '‚úì ' + files.listings.name + ' (' + files.listings.data.length + ' listings)',
          '‚úì ' + files.revenue.name + ' (' + files.revenue.data.length + ' revenue records)',
          files.bookings ? '‚úì ' + files.bookings.name + ' (' + files.bookings.data.length + ' bookings)' : null,
          '‚úì ' + files.market.name + ' (' + files.market.data.length + ' market records)',
          '‚úì ' + files.compsets.length + ' compset file(s)'
        ].filter(Boolean).map(s => '<li>' + s + '</li>').join('');
      }
    }

    // Parse date from various formats
    function parseDate(dateStr) {
      if (!dateStr) return null;
      if (dateStr instanceof Date) return dateStr;
      
      // Try parsing as-is
      let d = new Date(dateStr);
      if (!isNaN(d)) return d;
      
      // Try MM/DD/YYYY format
      const parts = dateStr.split('/');
      if (parts.length === 3) {
        d = new Date(parts[2], parts[0] - 1, parts[1]);
        if (!isNaN(d)) return d;
      }
      
      return null;
    }

    function runAnalysis() {
      const btn = document.getElementById('analyze-btn');
      btn.innerHTML = '<span class="loading"></span>Analyzing...';
      btn.disabled = true;

      setTimeout(() => {
        try {
          const portfolioName = document.getElementById('portfolio-name').value || 'Portfolio';
          const listingsData = files.listings.data;
          const revenueData = files.revenue.data;
          const marketData = files.market.data;
          const bookingsData = files.bookings ? files.bookings.data : [];

          console.log('Bookings data sample:', bookingsData.slice(0, 3));

          const portfolioIds = new Set(listingsData.map(l => l.ListingID));
          const bedroomLookup = {}, nameLookup = {};
          listingsData.forEach(l => {
            bedroomLookup[l.ListingID] = parseInt(l.Bedrooms) || 0;
            nameLookup[l.ListingID] = l.Listing || l['Listing Name'] || 'Unknown';
          });

          const compsetByBedroom = {};
          files.compsets.forEach(cs => {
            if (cs.data && cs.data.length > 0) {
              const bedrooms = parseInt(cs.data[0].Bedrooms) || 0;
              const revenues = cs.data.map(r => parseFloat(r.Revenue) || 0).filter(r => r > 0);
              if (revenues.length > 0) {
                if (bedrooms >= 5) { for (let b = 5; b <= 10; b++) compsetByBedroom[b] = (compsetByBedroom[b] || []).concat(revenues); }
                else compsetByBedroom[bedrooms] = revenues;
              }
            }
          });

          const monthOrder = { Jan: 1, Feb: 2, Mar: 3, Apr: 4, May: 5, Jun: 6, Jul: 7, Aug: 8, Sep: 9, Oct: 10, Nov: 11, Dec: 12 };
          const t12Months = [202502, 202503, 202504, 202505, 202506, 202507, 202508, 202509, 202510, 202511, 202512, 202601];

          const revenueByListing = {};
          revenueData.forEach(row => {
            const listingId = row['Listing ID'];
            if (!portfolioIds.has(listingId)) return;
            const month = monthOrder[row.Month], year = parseInt(row.Year);
            if (!month || !year) return;
            const yearMonth = year * 100 + month;
            if (t12Months.includes(yearMonth)) {
              if (!revenueByListing[listingId]) revenueByListing[listingId] = { total: 0, months: [], monthsWithRev: 0 };
              const rev = parseFloat(row.Revenue) || 0;
              revenueByListing[listingId].total += rev;
              revenueByListing[listingId].months.push({ yearMonth, revenue: rev });
              if (rev > 0) revenueByListing[listingId].monthsWithRev++;
            }
          });

          const marketByYearMonth = {}, marketLyByYearMonth = {};
          marketData.forEach(row => {
            const date = new Date(row.Date);
            if (isNaN(date)) return;
            const yearMonth = date.getFullYear() * 100 + (date.getMonth() + 1);
            if (!marketByYearMonth[yearMonth]) { marketByYearMonth[yearMonth] = []; marketLyByYearMonth[yearMonth] = []; }
            const occ = parseFloat(row.Occupancy), lyFinal = row['Occupancy (last year final)'];
            if (!isNaN(occ)) marketByYearMonth[yearMonth].push(occ);
            if (lyFinal && lyFinal !== 'NA' && !isNaN(parseFloat(lyFinal))) marketLyByYearMonth[yearMonth].push(parseFloat(lyFinal));
          });

          const avgMarketOcc = {}, avgMarketLy = {};
          Object.keys(marketByYearMonth).forEach(ym => { const vals = marketByYearMonth[ym]; avgMarketOcc[ym] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : 0; });
          Object.keys(marketLyByYearMonth).forEach(ym => { const vals = marketLyByYearMonth[ym]; avgMarketLy[ym] = vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : null; });

          const seasonality = {};
          let totalSeasonality = 0;
          t12Months.forEach(ym => { const lyYm = ym >= 202600 ? ym - 100 : ym; seasonality[ym] = avgMarketLy[lyYm] || avgMarketLy[ym] || 50; totalSeasonality += seasonality[ym]; });

          // FIRST PASS: Calculate 6+ month units to get average percentile
          const firstPassAnalysis = [];
          portfolioIds.forEach(listingId => {
            const data = revenueByListing[listingId] || { total: 0, months: [], monthsWithRev: 0 };
            const bedrooms = bedroomLookup[listingId];
            const monthsCount = data.monthsWithRev;
            const actualRevenue = data.total;
            
            if (monthsCount >= 6) {
              let projectedRevenue;
              if (monthsCount === 12) {
                projectedRevenue = actualRevenue;
              } else {
                const activeMonths = data.months.filter(m => m.revenue > 0).map(m => m.yearMonth);
                const activeSeasonality = activeMonths.reduce((sum, ym) => sum + (seasonality[ym] || 50), 0);
                projectedRevenue = activeSeasonality > 0 ? actualRevenue * (totalSeasonality / activeSeasonality) : actualRevenue;
              }
              
              let percentile = null;
              const compset = compsetByBedroom[bedrooms];
              if (compset && compset.length > 0 && projectedRevenue > 0) {
                percentile = percentileOfScore(compset, projectedRevenue);
              }
              
              if (percentile !== null) {
                firstPassAnalysis.push({ bedrooms, percentile });
              }
            }
          });

          // Calculate average percentile from 6+ month units
          const avgPercentile6Plus = firstPassAnalysis.length > 0 
            ? firstPassAnalysis.reduce((sum, l) => sum + l.percentile, 0) / firstPassAnalysis.length 
            : 50;
          
          console.log('Average percentile from 6+ month units:', avgPercentile6Plus);

          // SECOND PASS: Full analysis using avg percentile for <6 month units
          const listingsAnalysis = [];
          let currentT12 = 0, projectedT12 = 0;

          portfolioIds.forEach(listingId => {
            const data = revenueByListing[listingId] || { total: 0, months: [], monthsWithRev: 0 };
            const bedrooms = bedroomLookup[listingId], name = nameLookup[listingId];
            const monthsCount = data.monthsWithRev, actualRevenue = data.total;
            let projectedRevenue, method;

            if (monthsCount === 12) { 
              projectedRevenue = actualRevenue; 
              method = 'Actual (12 months)'; 
            } else if (monthsCount >= 6) {
              const activeMonths = data.months.filter(m => m.revenue > 0).map(m => m.yearMonth);
              const activeSeasonality = activeMonths.reduce((sum, ym) => sum + (seasonality[ym] || 50), 0);
              projectedRevenue = activeSeasonality > 0 ? actualRevenue * (totalSeasonality / activeSeasonality) : actualRevenue;
              method = 'Seasonality (' + monthsCount + ' months)';
            } else {
              // Use average percentile from 6+ month units to project revenue
              const compset = compsetByBedroom[bedrooms];
              if (compset && compset.length > 0) {
                projectedRevenue = valueAtPercentile(compset, avgPercentile6Plus);
                method = 'Avg Percentile (' + monthsCount + ' months)';
              } else {
                projectedRevenue = actualRevenue;
                method = 'No compset (' + monthsCount + ' months)';
              }
            }

            let percentile = null;
            const compset = compsetByBedroom[bedrooms];
            if (compset && compset.length > 0 && projectedRevenue > 0) percentile = percentileOfScore(compset, projectedRevenue);

            listingsAnalysis.push({ listingId, name, bedrooms, months: monthsCount, actualRevenue, projectedRevenue, percentile, method });
            currentT12 += actualRevenue;
            projectedT12 += projectedRevenue;
          });

          const units6Plus = listingsAnalysis.filter(l => l.months >= 6 && l.percentile !== null);
          const avgPercentile = units6Plus.length > 0 ? units6Plus.reduce((sum, l) => sum + l.percentile, 0) / units6Plus.length : 50;

          let percentileGrowth = 0.05;
          if (units6Plus.length > 0) {
            const bedCounts = {};
            units6Plus.forEach(l => { bedCounts[l.bedrooms] = (bedCounts[l.bedrooms] || 0) + 1; });
            let weightedPCurrent = 0, weightedP90 = 0;
            Object.entries(bedCounts).forEach(([bed, count]) => {
              const compset = compsetByBedroom[bed];
              if (compset && compset.length > 0) {
                const sorted = compset.slice().sort((a, b) => a - b);
                const pCurrentIdx = Math.min(Math.floor((avgPercentile / 100) * sorted.length), sorted.length - 1);
                const p90Idx = Math.min(Math.floor(0.9 * sorted.length), sorted.length - 1);
                weightedPCurrent += (sorted[pCurrentIdx] || 0) * count;
                weightedP90 += (sorted[p90Idx] || 0) * count;
              }
            });
            if (weightedPCurrent > 0) percentileGrowth = (weightedP90 / weightedPCurrent) - 1;
          }

          const pacingMonths = [
            { year: 2026, month: 3, name: 'Mar 2026' }, { year: 2026, month: 4, name: 'Apr 2026' },
            { year: 2026, month: 5, name: 'May 2026' }, { year: 2026, month: 6, name: 'Jun 2026' },
            { year: 2026, month: 7, name: 'Jul 2026' }, { year: 2026, month: 8, name: 'Aug 2026' },
            { year: 2026, month: 9, name: 'Sep 2026' }, { year: 2026, month: 10, name: 'Oct 2026' },
            { year: 2026, month: 11, name: 'Nov 2026' }, { year: 2026, month: 12, name: 'Dec 2026' },
          ];

          const lyFinals = Object.values(avgMarketLy).filter(v => v !== null && v > 0);
          const avgLyFinal = lyFinals.length > 0 ? lyFinals.reduce((a, b) => a + b, 0) / lyFinals.length : 50;
          const emoPct = avgLyFinal, targetOcc = 26.5 * Math.log(emoPct) - 24;
          const mpit = (targetOcc / emoPct) - (emoPct / 1000);

          // Process bookings - try multiple column name variations
          const bookingsByListing = {};
          let bookingsProcessed = 0;
          
          bookingsData.forEach(booking => {
            // Try different column names for listing ID
            const listingId = booking['Listing ID'] || booking['ListingID'] || booking['listing_id'] || booking['Listing Id'];
            if (!listingId || !portfolioIds.has(listingId)) return;
            
            // Try different column names for dates
            const checkinStr = booking['Check-in Date'] || booking['Check-in'] || booking['Checkin'] || booking['check_in_date'] || booking['CheckInDate'];
            const checkoutStr = booking['Check-out Date'] || booking['Check-out'] || booking['Checkout'] || booking['check_out_date'] || booking['CheckOutDate'];
            
            const checkin = parseDate(checkinStr);
            const checkout = parseDate(checkoutStr);
            
            if (!checkin || !checkout || isNaN(checkin) || isNaN(checkout)) return;
            
            if (!bookingsByListing[listingId]) bookingsByListing[listingId] = [];
            bookingsByListing[listingId].push({ checkin, checkout });
            bookingsProcessed++;
          });
          
          console.log('Bookings processed:', bookingsProcessed);
          console.log('Listings with bookings:', Object.keys(bookingsByListing).length);

          const countBookedNights = (listingId, year, month) => {
            const bookings = bookingsByListing[listingId] || [];
            const daysInMonth = new Date(year, month, 0).getDate();
            const monthStart = new Date(year, month - 1, 1);
            const monthEnd = new Date(year, month, 0, 23, 59, 59);
            
            let bookedNights = 0;
            bookings.forEach(b => {
              // Check if booking overlaps with this month
              if (b.checkout <= monthStart || b.checkin > monthEnd) return;
              
              const overlapStart = b.checkin < monthStart ? monthStart : b.checkin;
              const overlapEnd = b.checkout > monthEnd ? new Date(year, month, 1) : b.checkout;
              
              const nights = Math.ceil((overlapEnd - overlapStart) / (1000 * 60 * 60 * 24));
              if (nights > 0) bookedNights += nights;
            });
            
            return { bookedNights, daysInMonth };
          };

          const calculateScore = (ratio) => {
            if (ratio === null || ratio === undefined) return null;
            const distance = Math.abs(ratio - 1.0);
            if (distance < 0.10) return 5;
            if (distance < 0.25) return 4;
            if (distance < 0.40) return 3;
            if (distance < 0.50) return 2;
            return 1;
          };

          const pacingData = [];
          let totalWeight = 0, weightedScoreSum = 0;
          
          pacingMonths.forEach(pm => {
            const ym = pm.year * 100 + pm.month;
            const mktOcc = (avgMarketOcc[ym] || 0) / 100;
            const mktLy = avgMarketLy[ym] ? avgMarketLy[ym] / 100 : null;

            let totalBooked = 0, totalDays = 0;
            portfolioIds.forEach(listingId => {
              const result = countBookedNights(listingId, pm.year, pm.month);
              totalBooked += result.bookedNights;
              totalDays += result.daysInMonth;
            });

            const portOcc = totalDays > 0 ? totalBooked / totalDays : 0;
            const mpi = mktOcc > 0 ? portOcc / mktOcc : 0;
            let mpitMonth = null, ratio = null, score = null;

            if (mktLy && mktLy > 0) {
              const emoMonth = mktLy * 100, toMonth = 26.5 * Math.log(emoMonth) - 24;
              mpitMonth = (toMonth / emoMonth) - (emoMonth / 1000);
              ratio = mpitMonth > 0 ? mpi / mpitMonth : null;
              score = calculateScore(ratio);
              if (score !== null && mktOcc >= 0.01) { 
                totalWeight += mktOcc; 
                weightedScoreSum += score * mktOcc; 
              }
            }
            
            pacingData.push({ monthName: pm.name, portOcc, mktOcc, mpi, mktLy, mpit: mpitMonth, ratio, score });
          });

          const pacingScore = totalWeight > 0 ? Math.round((weightedScoreSum / totalWeight) * 100) / 100 : 2.5;

          const listingRatios = [];
          portfolioIds.forEach(listingId => {
            const monthlyMpis = [];
            pacingMonths.forEach(pm => {
              const ym = pm.year * 100 + pm.month, mktOcc = (avgMarketOcc[ym] || 0) / 100;
              if (mktOcc < 0.01) return;
              const result = countBookedNights(listingId, pm.year, pm.month);
              const occ = result.daysInMonth > 0 ? result.bookedNights / result.daysInMonth : 0;
              if (mktOcc > 0) monthlyMpis.push(occ / mktOcc);
            });
            if (monthlyMpis.length > 0) listingRatios.push(mpit > 0 ? monthlyMpis.reduce((a, b) => a + b, 0) / monthlyMpis.length / mpit : 0);
          });

          let coeffVar = 0.5, consistencyScore = 3;
          if (listingRatios.length > 2) {
            const sorted = listingRatios.slice().sort((a, b) => a - b);
            const p5Idx = Math.floor(0.05 * sorted.length), p95Idx = Math.floor(0.95 * sorted.length);
            const filtered = sorted.slice(p5Idx, p95Idx + 1);
            if (filtered.length > 0) {
              const mean = filtered.reduce((a, b) => a + b, 0) / filtered.length;
              const variance = filtered.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / filtered.length;
              coeffVar = mean > 0 ? Math.sqrt(variance) / mean : 0.5;
            }
          }
          if (coeffVar < 0.40) consistencyScore = 5;
          else if (coeffVar < 0.60) consistencyScore = 4;
          else if (coeffVar < 0.80) consistencyScore = 3;
          else if (coeffVar < 1.00) consistencyScore = 2;
          else consistencyScore = 1;

          const avgScore = (pacingScore + consistencyScore) / 2;
          const pacingGrowth = 0.20 - ((avgScore - 1) * 0.05);
          const rpmGrowth = (pacingGrowth + percentileGrowth) / 2;

          const marketOccByMonth = pacingMonths.map(pm => (avgMarketOcc[pm.year * 100 + pm.month] || 0) / 100);
          const avgMarketOccVal = marketOccByMonth.reduce((a, b) => a + b, 0) / marketOccByMonth.length;

          const listingPacingData = [];
          portfolioIds.forEach(listingId => {
            const name = nameLookup[listingId], bedrooms = bedroomLookup[listingId];
            const monthlyOcc = pacingMonths.map(pm => {
              const result = countBookedNights(listingId, pm.year, pm.month);
              return result.daysInMonth > 0 ? result.bookedNights / result.daysInMonth : 0;
            });
            const monthlyMpi = monthlyOcc.map((occ, i) => marketOccByMonth[i] > 0 ? occ / marketOccByMonth[i] : null);
            const validMpis = monthlyMpi.filter(m => m !== null);
            const avgOcc = monthlyOcc.reduce((a, b) => a + b, 0) / monthlyOcc.length;
            const avgMpi = validMpis.length > 0 ? validMpis.reduce((a, b) => a + b, 0) / validMpis.length : null;
            const mpiMpitRatio = avgMpi !== null && mpit > 0 ? avgMpi / mpit : null;
            listingPacingData.push({ name, bedrooms, monthlyOcc, avgOcc, avgMpi, mpit, mpiMpitRatio });
          });
          listingPacingData.sort((a, b) => a.name.localeCompare(b.name));

          const feeInfo = getFeeRate(projectedT12);
          const newProjectedRevenue = projectedT12 * (1 + rpmGrowth);
          const rpmFee = newProjectedRevenue * feeInfo.rate;
          const revenueIncrease = newProjectedRevenue - projectedT12;
          const newNetRevenue = revenueIncrease - rpmFee;

          analysis = {
            portfolioName,
            currentT12: roundTo100k(currentT12),
            projectedT12: roundTo100k(projectedT12),
            avgPercentile: Math.round(avgPercentile),
            pacingScore,
            consistencyScore,
            avgScore: Math.round(avgScore * 100) / 100,
            coeffVar: Math.round(coeffVar * 100),
            rpmGrowth: Math.round(rpmGrowth * 100),
            rpmRate: feeInfo.rate,
            rpmTier: feeInfo.tier,
            newProjectedRevenue: roundTo5k(newProjectedRevenue),
            rpmFee: roundTo1k(rpmFee),
            newNetRevenue: roundTo1k(revenueIncrease - rpmFee),
            listingsAnalysis,
            units6PlusCount: units6Plus.length,
            totalUnits: listingsAnalysis.length,
            pacingData,
            listingPacingData,
            marketOccByMonth,
            avgMarketOcc: avgMarketOccVal,
            mpit
          };

          renderResults();
          goToStep(3);
        } catch (err) {
          console.error(err);
          showError(err.message);
        } finally {
          btn.innerHTML = 'Run Analysis ‚Üí';
          btn.disabled = false;
        }
      }, 100);
    }

    function renderResults() {
      const resultsGrid = document.getElementById('results-grid');
      resultsGrid.innerHTML = [
        { label: 'Current T-12', value: formatCurrency(analysis.currentT12), class: 'highlight' },
        { label: 'Full Potential', value: formatCurrency(analysis.projectedT12), class: 'highlight' },
        { label: 'RPM Growth', value: analysis.rpmGrowth + '%', class: 'accent' },
        { label: 'New Projected Revenue', value: formatCurrency(analysis.newProjectedRevenue), class: 'accent' },
        { label: 'RPM Fee (' + (analysis.rpmRate * 100).toFixed(2) + '%)', value: formatCurrency(analysis.rpmFee), class: '' },
        { label: 'Net Revenue Gain', value: formatCurrency(analysis.newNetRevenue), class: 'success' },
      ].map(r => '<div class="result-card ' + r.class + '"><div class="card-label">' + r.label + '</div><div class="card-value">' + r.value + '</div></div>').join('');

      const scoresGrid = document.getElementById('scores-grid');
      scoresGrid.innerHTML = [
        { label: 'Pacing Score', value: analysis.pacingScore.toFixed(2) },
        { label: 'Consistency Score', value: analysis.consistencyScore },
        { label: 'Average Score', value: analysis.avgScore },
        { label: 'Avg Percentile (6+ mo)', value: analysis.avgPercentile + '%' },
      ].map(s => '<div class="score-item"><div class="score-label">' + s.label + '</div><div class="score-value">' + s.value + '</div></div>').join('');

      document.getElementById('unit-summary-text').textContent = analysis.totalUnits + ' total units ‚Ä¢ ' + analysis.units6PlusCount + ' with 6+ months data';
    }

    function generateExcel() {
      const wb = XLSX.utils.book_new();
      const currencyFmt = '"$"#,##0';
      const pctFmt = '0%';
      const pct1Fmt = '0.0%';

      // DASHBOARD
      const dashboardData = [
        ['Portfolio Dashboard - ' + analysis.portfolioName], [],
        ['Revenue Summary'], ['Metric', 'Value'],
        ['Current T-12 Revenue', analysis.currentT12],
        ['Current Full Potential Revenue', analysis.projectedT12], [],
        ['RPM Growth Projection'], ['Metric', 'Value'],
        ['RPM Growth %', analysis.rpmGrowth / 100],
        ['RPM Fee Rate', analysis.rpmRate],
        ['RPM Fee (Annual)', analysis.rpmFee],
        ['New Projected Revenue', analysis.newProjectedRevenue],
        ['New Net Revenue (Growth - Fee)', analysis.newNetRevenue], [],
        ['Units with 6+ Months Data'], ['Bedrooms', 'Units', 'Avg Projected Rev', 'Avg Percentile'],
      ];

      const bedStats = {};
      analysis.listingsAnalysis.filter(l => l.months >= 6).forEach(l => {
        if (!bedStats[l.bedrooms]) bedStats[l.bedrooms] = { count: 0, revenue: 0, percentiles: [] };
        bedStats[l.bedrooms].count++;
        bedStats[l.bedrooms].revenue += l.projectedRevenue;
        if (l.percentile) bedStats[l.bedrooms].percentiles.push(l.percentile);
      });

      Object.keys(bedStats).sort((a, b) => a - b).forEach(bed => {
        const s = bedStats[bed];
        dashboardData.push([bed + ' Bedroom', s.count, s.revenue / s.count, s.percentiles.length > 0 ? s.percentiles.reduce((a, b) => a + b, 0) / s.percentiles.length / 100 : null]);
      });

      const units6Plus = analysis.listingsAnalysis.filter(l => l.months >= 6);
      const allPcts = units6Plus.filter(l => l.percentile).map(l => l.percentile);
      dashboardData.push(['Total', units6Plus.length, units6Plus.reduce((s, l) => s + l.projectedRevenue, 0) / (units6Plus.length || 1), allPcts.length > 0 ? allPcts.reduce((a, b) => a + b, 0) / allPcts.length / 100 : null]);
      dashboardData.push([], ['Pacing Scores'], ['Metric', 'Value', 'Score']);
      dashboardData.push(['Pacing Score', 'Weighted Avg MPI/MPIT', analysis.pacingScore]);
      dashboardData.push(['Consistency Score', 'CV: ' + analysis.coeffVar + '%', analysis.consistencyScore]);
      dashboardData.push(['Average Score', '', analysis.avgScore]);

      const dashboardSheet = XLSX.utils.aoa_to_sheet(dashboardData);
      dashboardSheet['!cols'] = [{ wch: 32 }, { wch: 22 }, { wch: 18 }, { wch: 16 }];
      ['B5', 'B6', 'B12', 'B13', 'B14'].forEach(ref => { if (dashboardSheet[ref]) dashboardSheet[ref].z = currencyFmt; });
      ['B10', 'B11'].forEach(ref => { if (dashboardSheet[ref]) dashboardSheet[ref].z = pct1Fmt; });
      XLSX.utils.book_append_sheet(wb, dashboardSheet, 'Dashboard');

      // T-12 REVENUE
      const revenueSheetData = [['T-12 Revenue Analysis (Feb 2025 - Jan 2026)'], [], ['Listing Name', 'BR', 'Months', 'Actual Revenue', 'Projected Revenue', 'Method', 'Percentile']];
      [...analysis.listingsAnalysis].sort((a, b) => b.months - a.months || a.name.localeCompare(b.name)).forEach(l => {
        revenueSheetData.push([l.name, l.bedrooms, l.months, l.actualRevenue, Math.round(l.projectedRevenue), l.method, l.percentile ? l.percentile / 100 : 'N/A']);
      });
      revenueSheetData.push(['Total', '', '', analysis.listingsAnalysis.reduce((s, l) => s + l.actualRevenue, 0), analysis.listingsAnalysis.reduce((s, l) => s + l.projectedRevenue, 0), '', '']);
      const revenueSheet = XLSX.utils.aoa_to_sheet(revenueSheetData);
      revenueSheet['!cols'] = [{ wch: 55 }, { wch: 6 }, { wch: 10 }, { wch: 16 }, { wch: 18 }, { wch: 24 }, { wch: 12 }];
      for (let i = 4; i <= revenueSheetData.length; i++) {
        if (revenueSheet['D' + i]) revenueSheet['D' + i].z = currencyFmt;
        if (revenueSheet['E' + i]) revenueSheet['E' + i].z = currencyFmt;
        if (revenueSheet['G' + i] && typeof revenueSheet['G' + i].v === 'number') revenueSheet['G' + i].z = pctFmt;
      }
      XLSX.utils.book_append_sheet(wb, revenueSheet, 'T-12 Revenue');

      // OCCUPANCY PACING
      if (analysis.pacingData.length > 0) {
        const pacingSheetData = [['Portfolio Occupancy Pacing (Mar-Dec 2026)'], [], ['Month', 'Portfolio Occ', 'Market Occ', 'MPI', 'Market LY Final', 'MPIT', 'MPI/MPIT', 'Score']];
        analysis.pacingData.forEach(d => {
          pacingSheetData.push([d.monthName, d.portOcc, d.mktOcc, d.mpi, d.mktLy !== null ? d.mktLy : 'N/A', d.mpit !== null ? d.mpit : 'N/A', d.ratio !== null ? d.ratio : 'N/A', d.score !== null ? d.score : 'N/A']);
        });
        pacingSheetData.push(['Weighted Average', '', '', '', '', '', '', analysis.pacingScore]);
        const pacingSheet = XLSX.utils.aoa_to_sheet(pacingSheetData);
        pacingSheet['!cols'] = Array(8).fill({ wch: 14 });
        for (let i = 4; i < pacingSheetData.length; i++) {
          ['B', 'C', 'E'].forEach(col => { if (pacingSheet[col + i] && typeof pacingSheet[col + i].v === 'number') pacingSheet[col + i].z = pct1Fmt; });
          ['D', 'F', 'G'].forEach(col => { if (pacingSheet[col + i] && typeof pacingSheet[col + i].v === 'number') pacingSheet[col + i].z = pctFmt; });
        }
        XLSX.utils.book_append_sheet(wb, pacingSheet, 'Occupancy Pacing');
      }

      // LISTING PACING
      if (analysis.listingPacingData.length > 0) {
        const months = ['Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const listingPacingSheetData = [['Listing Pacing - Forward Occupancy (Mar-Dec 2026)'], [], ['Listing Name', 'BR', ...months, 'Avg Occ', 'Avg MPI', 'MPIT', 'MPI/MPIT'],
          ['Market Occupancy', '', ...analysis.marketOccByMonth, analysis.avgMarketOcc, '', '', '']];
        analysis.listingPacingData.forEach(l => {
          listingPacingSheetData.push([l.name, l.bedrooms, ...l.monthlyOcc, l.avgOcc, l.avgMpi, l.mpit, l.mpiMpitRatio]);
        });
        const lastRow = 4 + analysis.listingPacingData.length;
        const avgRow = ['Portfolio Average', ''];
        for (let col = 2; col < 2 + months.length + 4; col++) {
          const colLetter = XLSX.utils.encode_col(col);
          avgRow.push({ f: 'AVERAGE(' + colLetter + '5:' + colLetter + lastRow + ')' });
        }
        listingPacingSheetData.push(avgRow);
        const listingPacingSheet = XLSX.utils.aoa_to_sheet(listingPacingSheetData);
        listingPacingSheet['!cols'] = [{ wch: 55 }, { wch: 5 }, ...Array(months.length + 4).fill({ wch: 8 })];
        for (let i = 4; i <= listingPacingSheetData.length; i++) {
          for (let j = 2; j < 2 + months.length + 4; j++) {
            const ref = XLSX.utils.encode_cell({ r: i - 1, c: j });
            if (listingPacingSheet[ref] && typeof listingPacingSheet[ref].v === 'number') {
              listingPacingSheet[ref].z = j < 2 + months.length + 2 ? pct1Fmt : pctFmt;
            }
          }
        }
        XLSX.utils.book_append_sheet(wb, listingPacingSheet, 'Listing Pacing');
      }

      XLSX.writeFile(wb, analysis.portfolioName.replace(/\s+/g, '_') + '_T12_Revenue.xlsx');
    }
  </script>
</body>
</html>
